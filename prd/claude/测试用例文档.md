# HSMY 项目测试用例文档

## 版本信息
- **文档版本**: v1.0
- **测试框架**: JUnit 5 + Spring Boot Test + RestTemplate
- **项目版本**: HSMY v1.0-SNAPSHOT
- **创建日期**: 2025-09-27

## 测试环境配置

### 基础环境
- **Java版本**: 1.8
- **Spring Boot版本**: 2.7.14
- **数据库**: MySQL 8.0.33
- **缓存**: Redis
- **测试端口**: 8080

### 测试数据准备
```sql
-- 测试用户数据
INSERT INTO user (id, username, phone, email, password, status, create_time) VALUES
(1, 'test_user_1', '13800138001', 'test1@example.com', 'e10adc3949ba59abbe56e057f20f883e', 1, NOW()),
(2, 'test_user_2', '13800138002', 'test2@example.com', 'e10adc3949ba59abbe56e057f20f883e', 1, NOW());

-- 测试功德等级数据
INSERT INTO merit_level (id, level_name, min_merit, max_merit, exchange_rate) VALUES
(1, '初心者', 0, 999, 1),
(2, '修行者', 1000, 4999, 2);

-- 测试道具数据
INSERT INTO item (id, item_name, item_type, price, stock, status) VALUES
(1, '祈福香', 'CONSUMABLE', 100, 999, 1),
(2, '功德锦囊', 'SPECIAL', 500, 50, 1);
```

---

## 一、手动测试用例

### 1. 认证模块测试用例

#### TC001: 发送验证码测试
**测试目标**: 验证发送验证码功能
**前置条件**: 无
**测试步骤**:
```bash
# 1. 发送手机验证码
curl -X POST http://localhost:8080/auth/send-code \
  -H "Content-Type: application/json" \
  -d '{
    "account": "13800138888",
    "accountType": "phone",
    "businessType": "register"
  }'

# 2. 发送邮箱验证码
curl -X POST http://localhost:8080/auth/send-code \
  -H "Content-Type: application/json" \
  -d '{
    "account": "test@example.com",
    "accountType": "email",
    "businessType": "login"
  }'
```
**预期结果**: 
- 返回 `code: 200`, `message: "验证码已发送，请查收"`
- 收到验证码短信/邮件

#### TC002: 验证码注册测试
**测试目标**: 验证通过验证码注册新用户
**前置条件**: 已发送验证码
**测试步骤**:
```bash
curl -X POST http://localhost:8080/auth/register-by-code \
  -H "Content-Type: application/json" \
  -d '{
    "account": "13800138888",
    "code": "123456",
    "nickname": "测试用户"
  }'
```
**预期结果**: 
- 返回 `code: 200`
- 返回用户信息和token

#### TC003: 用户登录测试
**测试目标**: 验证密码登录和验证码登录
**前置条件**: 用户已注册
**测试步骤**:
```bash
# 密码登录
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "loginAccount": "test_user_1",
    "loginType": "password",
    "password": "123456"
  }'

# 验证码登录
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "loginAccount": "13800138001",
    "loginType": "code",
    "code": "654321"
  }'
```
**预期结果**: 
- 返回 `code: 200`
- 返回sessionId和用户信息

#### TC004: 异常场景测试
**测试目标**: 验证各种异常情况处理
**测试步骤**:
```bash
# 1. 无效手机号
curl -X POST http://localhost:8080/auth/send-code \
  -H "Content-Type: application/json" \
  -d '{"account": "12345", "accountType": "phone", "businessType": "register"}'

# 2. 错误密码登录
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"loginAccount": "test_user_1", "loginType": "password", "password": "wrong"}'

# 3. 过期验证码
curl -X POST http://localhost:8080/auth/register-by-code \
  -H "Content-Type: application/json" \
  -d '{"account": "13800138888", "code": "expired_code"}'
```
**预期结果**: 
- 返回相应错误码和错误信息

### 2. 敲击模块测试用例

#### TC005: 手动敲击测试
**测试目标**: 验证手动敲击功能
**前置条件**: 用户已登录
**测试步骤**:
```bash
# 获取登录token
TOKEN="Bearer sess_123456789"

curl -X POST http://localhost:8080/knock/manual \
  -H "Content-Type: application/json" \
  -H "Authorization: $TOKEN" \
  -d '{
    "knockCount": 10,
    "knockSound": "default",
    "sessionDuration": 60
  }'
```
**预期结果**: 
- 返回敲击成功信息
- 功德值增加

#### TC006: 自动敲击流程测试
**测试目标**: 验证自动敲击完整流程
**前置条件**: 用户已登录
**测试步骤**:
```bash
# 1. 开始自动敲击
curl -X POST http://localhost:8080/knock/auto/start \
  -H "Content-Type: application/json" \
  -H "Authorization: $TOKEN" \
  -d '{
    "duration": 300,
    "knockInterval": 1000,
    "knockSound": "default"
  }'

# 2. 发送心跳（多次）
curl -X POST http://localhost:8080/knock/auto/heartbeat \
  -H "Content-Type: application/json" \
  -H "Authorization: $TOKEN" \
  -d '{
    "sessionId": "auto_knock_sess_123",
    "currentKnockCount": 50
  }'

# 3. 停止自动敲击
curl -X POST http://localhost:8080/knock/auto/stop \
  -H "Content-Type: application/json" \
  -H "Authorization: $TOKEN" \
  -d '{
    "sessionId": "auto_knock_sess_123",
    "actualDuration": 250
  }'
```

### 3. 功德模块测试用例

#### TC007: 功德统计测试
**测试目标**: 验证功德统计功能
**前置条件**: 用户已有功德记录
**测试步骤**:
```bash
# 获取功德余额
curl -X POST http://localhost:8080/merit/balance \
  -H "Authorization: $TOKEN"

# 获取功德汇总
curl -X GET http://localhost:8080/merit/summary \
  -H "Authorization: $TOKEN"

# 获取日功德统计
curl -X GET "http://localhost:8080/merit/daily?date=2025-09-27" \
  -H "Authorization: $TOKEN"
```

#### TC008: 功德兑换测试
**测试目标**: 验证功德兑换功德币功能
**前置条件**: 用户有足够功德
**测试步骤**:
```bash
curl -X POST http://localhost:8080/merit/exchange \
  -H "Content-Type: application/json" \
  -H "Authorization: $TOKEN" \
  -d '{
    "exchangeAmount": 100,
    "exchangeRate": 1
  }'
```

### 4. 商城模块测试用例

#### TC009: 商城购买流程测试
**测试目标**: 验证完整购买流程
**前置条件**: 用户有足够功德币
**测试步骤**:
```bash
# 1. 获取道具列表
curl -X GET http://localhost:8080/shop/items

# 2. 获取道具详情
curl -X GET http://localhost:8080/shop/items/1

# 3. 购买道具
curl -X POST "http://localhost:8080/shop/purchase?itemId=1&quantity=1" \
  -H "Authorization: $TOKEN"
```

### 5. 性能测试用例

#### TC010: 并发敲击测试
**测试目标**: 验证高并发场景下的系统稳定性
**工具**: Apache Bench (ab)
**测试步骤**:
```bash
# 并发100个请求，总共1000个请求
ab -n 1000 -c 100 -T "application/json" \
   -H "Authorization: Bearer sess_123456789" \
   -p knock_data.json \
   http://localhost:8080/knock/manual
```

---

## 二、自动化测试用例

### 1. 单元测试

#### AuthControllerTest.java
```java
package com.hsmy.controller;

import com.hsmy.controller.auth.AuthController;
import com.hsmy.service.UserService;
import com.hsmy.service.SessionService;
import com.hsmy.service.VerificationCodeService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.mockito.Mockito.*;

@WebMvcTest(AuthController.class)
class AuthControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;
    
    @MockBean
    private SessionService sessionService;
    
    @MockBean
    private VerificationCodeService verificationCodeService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void testSendCode_Success() throws Exception {
        // 准备测试数据
        SendCodeRequest request = new SendCodeRequest();
        request.setAccount("13800138888");
        request.setAccountType("phone");
        request.setBusinessType("register");

        // 模拟服务层返回
        when(verificationCodeService.sendCode(any(), any(), any(), any()))
            .thenReturn(true);

        // 执行测试
        mockMvc.perform(post("/auth/send-code")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(200))
                .andExpect(jsonPath("$.message").value("验证码已发送，请查收"));
    }

    @Test
    void testSendCode_InvalidPhone() throws Exception {
        SendCodeRequest request = new SendCodeRequest();
        request.setAccount("12345");
        request.setAccountType("phone");
        request.setBusinessType("register");

        mockMvc.perform(post("/auth/send-code")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(500))
                .andExpect(jsonPath("$.message").value("手机号格式不正确"));
    }
}
```

#### KnockServiceTest.java
```java
package com.hsmy.service;

import com.hsmy.service.impl.KnockServiceImpl;
import com.hsmy.mapper.KnockRecordMapper;
import com.hsmy.mapper.UserStatsMapper;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.TestPropertySource;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.yml")
class KnockServiceTest {

    @MockBean
    private KnockRecordMapper knockRecordMapper;
    
    @MockBean
    private UserStatsMapper userStatsMapper;
    
    private KnockService knockService;

    @BeforeEach
    void setUp() {
        knockService = new KnockServiceImpl(knockRecordMapper, userStatsMapper);
    }

    @Test
    void testManualKnock_Success() {
        // 准备测试数据
        KnockVO knockVO = new KnockVO();
        knockVO.setUserId(1L);
        knockVO.setKnockCount(10);
        knockVO.setKnockMode("MANUAL");

        // 模拟数据库操作
        when(userStatsMapper.selectByUserId(1L))
            .thenReturn(createTestUserStats());
        when(knockRecordMapper.insert(any()))
            .thenReturn(1);

        // 执行测试
        Map<String, Object> result = knockService.manualKnock(knockVO);

        // 验证结果
        assertNotNull(result);
        assertEquals(10, result.get("knockCount"));
        assertTrue((Integer) result.get("meritGained") > 0);
    }

    @Test
    void testConcurrentKnock() throws InterruptedException {
        // 并发测试
        int threadCount = 10;
        CountDownLatch latch = new CountDownLatch(threadCount);
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);

        for (int i = 0; i < threadCount; i++) {
            executor.submit(() -> {
                try {
                    KnockVO knockVO = new KnockVO();
                    knockVO.setUserId(1L);
                    knockVO.setKnockCount(1);
                    knockService.manualKnock(knockVO);
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();
        executor.shutdown();

        // 验证最终状态
        verify(knockRecordMapper, times(threadCount)).insert(any());
    }
}
```

### 2. 集成测试

#### AuthIntegrationTest.java
```java
package com.hsmy.integration;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureWebMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebMvc
@TestPropertySource(locations = "classpath:application-test.yml")
@Transactional
class AuthIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void testCompleteAuthFlow() throws Exception {
        // 1. 发送验证码
        SendCodeRequest sendCodeRequest = new SendCodeRequest();
        sendCodeRequest.setAccount("13800138999");
        sendCodeRequest.setAccountType("phone");
        sendCodeRequest.setBusinessType("register");

        mockMvc.perform(post("/auth/send-code")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(sendCodeRequest)))
                .andExpect(status().isOk());

        // 2. 模拟注册（使用测试验证码）
        RegisterByCodeRequest registerRequest = new RegisterByCodeRequest();
        registerRequest.setAccount("13800138999");
        registerRequest.setCode("TEST_CODE");
        registerRequest.setNickname("集成测试用户");

        MvcResult registerResult = mockMvc.perform(post("/auth/register-by-code")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(registerRequest)))
                .andExpect(status().isOk())
                .andReturn();

        // 提取token
        String response = registerResult.getResponse().getContentAsString();
        JsonNode jsonNode = objectMapper.readTree(response);
        String token = jsonNode.get("data").get("token").asText();

        // 3. 使用token访问需要认证的接口
        mockMvc.perform(get("/user/self/info")
                .header("Authorization", "Bearer " + token))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.data.phone").value("13800138999"));

        // 4. 登出
        mockMvc.perform(post("/auth/logout")
                .header("Authorization", "Bearer " + token))
                .andExpect(status().isOk());
    }
}
```

### 3. API端到端测试

#### ApiEndToEndTest.java
```java
package com.hsmy.e2e;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.boot.test.context.SpringBootTest;

import static io.restassured.RestAssured.*;
import static org.hamcrest.Matchers.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class ApiEndToEndTest {

    private static String authToken;

    @BeforeAll
    static void setUp() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = 8080;
    }

    @Test
    @Order(1)
    void testUserRegistrationAndLogin() {
        // 注册用户
        String registerPayload = "{"
            + "\"account\": \"13900139000\","
            + "\"code\": \"TEST_CODE\","
            + "\"nickname\": \"E2E测试用户\""
            + "}";

        authToken = given()
            .contentType(ContentType.JSON)
            .body(registerPayload)
        .when()
            .post("/auth/register-by-code")
        .then()
            .statusCode(200)
            .body("code", equalTo(200))
            .extract()
            .path("data.token");
    }

    @Test
    @Order(2)
    void testKnockFlow() {
        // 手动敲击
        String knockPayload = "{"
            + "\"knockCount\": 5,"
            + "\"knockSound\": \"default\","
            + "\"sessionDuration\": 30"
            + "}";

        given()
            .header("Authorization", "Bearer " + authToken)
            .contentType(ContentType.JSON)
            .body(knockPayload)
        .when()
            .post("/knock/manual")
        .then()
            .statusCode(200)
            .body("code", equalTo(200))
            .body("data.knockCount", equalTo(5));
    }

    @Test
    @Order(3)
    void testMeritOperations() {
        // 查看功德余额
        given()
            .header("Authorization", "Bearer " + authToken)
        .when()
            .post("/merit/balance")
        .then()
            .statusCode(200)
            .body("data.totalMerit", greaterThan(0));

        // 兑换功德币
        String exchangePayload = "{"
            + "\"exchangeAmount\": 5,"
            + "\"exchangeRate\": 1"
            + "}";

        given()
            .header("Authorization", "Bearer " + authToken)
            .contentType(ContentType.JSON)
            .body(exchangePayload)
        .when()
            .post("/merit/exchange")
        .then()
            .statusCode(200)
            .body("code", equalTo(200));
    }

    @Test
    @Order(4)
    void testShopPurchase() {
        // 获取道具列表
        given()
        .when()
            .get("/shop/items")
        .then()
            .statusCode(200)
            .body("data", not(empty()));

        // 购买道具
        given()
            .header("Authorization", "Bearer " + authToken)
            .param("itemId", 1)
            .param("quantity", 1)
        .when()
            .post("/shop/purchase")
        .then()
            .statusCode(200)
            .body("data.success", equalTo(true));
    }
}
```

### 4. 性能测试

#### PerformanceTest.java
```java
package com.hsmy.performance;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.yml")
class PerformanceTest {

    @Test
    void testKnockServicePerformance() throws Exception {
        int concurrentUsers = 100;
        int operationsPerUser = 10;
        ExecutorService executor = Executors.newFixedThreadPool(concurrentUsers);

        long startTime = System.currentTimeMillis();

        CompletableFuture<Void>[] futures = new CompletableFuture[concurrentUsers];
        for (int i = 0; i < concurrentUsers; i++) {
            final int userId = i + 1;
            futures[i] = CompletableFuture.runAsync(() -> {
                for (int j = 0; j < operationsPerUser; j++) {
                    // 模拟敲击操作
                    performKnockOperation(userId);
                }
            }, executor);
        }

        CompletableFuture.allOf(futures).get(30, TimeUnit.SECONDS);
        long endTime = System.currentTimeMillis();

        long totalOperations = concurrentUsers * operationsPerUser;
        long totalTime = endTime - startTime;
        double throughput = (double) totalOperations / (totalTime / 1000.0);

        System.out.println("性能测试结果:");
        System.out.println("总操作数: " + totalOperations);
        System.out.println("总耗时: " + totalTime + "ms");
        System.out.println("吞吐量: " + String.format("%.2f", throughput) + " ops/sec");

        // 断言性能要求
        assertTrue(throughput > 100, "吞吐量应该大于100 ops/sec");
        assertTrue(totalTime < 10000, "总耗时应该小于10秒");

        executor.shutdown();
    }

    private void performKnockOperation(int userId) {
        // 具体的敲击操作实现
        try {
            // 模拟网络延迟
            Thread.sleep(10);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 三、测试配置文件

### application-test.yml
```yaml
spring:
  profiles:
    active: test
  
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
    
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    
  redis:
    host: localhost
    port: 6379
    database: 1
    
logging:
  level:
    com.hsmy: DEBUG
    org.springframework.web: DEBUG

# 测试专用配置
test:
  mock:
    verification-code: "TEST_CODE"
    sms-service: true
  
hsmy:
  session:
    timeout: 3600
  merit:
    base-rate: 1
```

### TestDataBuilder.java
```java
package com.hsmy.test.util;

import com.hsmy.entity.User;
import com.hsmy.entity.UserStats;

public class TestDataBuilder {
    
    public static User createTestUser(Long id) {
        User user = new User();
        user.setId(id);
        user.setUsername("test_user_" + id);
        user.setPhone("1380013800" + id);
        user.setEmail("test" + id + "@example.com");
        user.setPassword("e10adc3949ba59abbe56e057f20f883e"); // 123456
        user.setStatus(1);
        user.setCreateTime(new Date());
        return user;
    }
    
    public static UserStats createTestUserStats(Long userId) {
        UserStats stats = new UserStats();
        stats.setUserId(userId);
        stats.setTotalMerit(1000L);
        stats.setMeritCoins(500L);
        stats.setTotalKnocks(100L);
        stats.setCreateTime(new Date());
        return stats;
    }
}
```

---

## 四、测试执行指南

### 1. 手动测试执行

#### 环境准备
```bash
# 1. 启动应用
mvn spring-boot:run

# 2. 验证服务状态
curl http://localhost:8080/auth/health

# 3. 准备测试数据
mysql -u root -p hsmy < test_data.sql
```

#### 测试执行流程
1. **冒烟测试**: 执行基础功能测试确保服务正常
2. **功能测试**: 按模块执行完整功能测试
3. **异常测试**: 验证各种边界条件和异常场景
4. **性能测试**: 使用工具进行压力测试

### 2. 自动化测试执行

#### 单元测试
```bash
# 运行所有单元测试
mvn test

# 运行特定测试类
mvn test -Dtest=AuthControllerTest

# 生成测试报告
mvn test jacoco:report
```

#### 集成测试
```bash
# 运行集成测试
mvn test -Dtest=**/*IntegrationTest

# 运行E2E测试
mvn test -Dtest=**/*EndToEndTest
```

#### 性能测试
```bash
# 运行性能测试
mvn test -Dtest=**/*PerformanceTest

# 使用JMeter进行压力测试
jmeter -n -t hsmy_load_test.jmx -l results.jtl
```

### 3. 持续集成配置

#### GitHub Actions配置
```yaml
name: HSMY Test Pipeline

on:
  push:
    branches: [ master, develop ]
  pull_request:
    branches: [ master ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: hsmy_test
        ports:
          - 3306:3306
      
      redis:
        image: redis:6.2
        ports:
          - 6379:6379
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up JDK 1.8
      uses: actions/setup-java@v2
      with:
        java-version: '8'
        distribution: 'adopt'
    
    - name: Cache Maven dependencies
      uses: actions/cache@v2
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
    
    - name: Run tests
      run: mvn clean test
    
    - name: Generate test report
      run: mvn jacoco:report
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
```

---

## 五、测试结果评估

### 1. 测试覆盖率目标
- **代码覆盖率**: ≥80%
- **分支覆盖率**: ≥75%
- **API覆盖率**: 100%

### 2. 性能基准
- **响应时间**: 平均 ≤ 200ms
- **吞吐量**: ≥ 100 req/sec
- **并发用户**: 支持 ≥ 100并发

### 3. 测试报告模板
```markdown
## 测试执行报告

### 测试概要
- 测试日期: 2025-09-27
- 测试环境: Test
- 测试人员: 张三

### 测试结果
- 总用例数: 50
- 通过用例: 48
- 失败用例: 2
- 通过率: 96%

### 失败用例分析
1. TC008: 功德兑换边界值测试 - 需要优化边界条件处理
2. TC010: 并发敲击测试 - 发现轻微的竞态条件

### 建议
1. 修复边界值处理逻辑
2. 优化并发控制机制
3. 增加更多异常场景测试
```

---

## 六、测试最佳实践

### 1. 测试原则
- **独立性**: 每个测试用例应该独立运行
- **可重复性**: 测试结果应该是可重复的
- **快速反馈**: 测试应该快速执行并提供反馈
- **全面性**: 覆盖正常流程、异常流程和边界条件

### 2. 测试数据管理
- 使用Builder模式构建测试数据
- 测试后清理数据，避免测试间相互影响
- 使用固定的测试数据，确保结果可预期

### 3. 测试维护
- 定期更新测试用例，保持与代码同步
- 重构重复的测试代码
- 建立测试用例评审机制

---

*本测试用例文档将随着系统功能的更新而持续完善和更新。*